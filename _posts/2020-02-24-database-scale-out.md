---
layout: post
title: DB 샤딩
comments: true
---
# 네 대의 서버

## 마스터 - 슬레이브 방식
* Write가 2번 해야함
* 읽기 부하는 분산, 쓰기(복제)시간 증가
* 데이터 싱크 문제로 확인 절차 필요

# 클러스터링
* 데이터를 자동으로 분산 저장
* 노드간 재균형 작업

# 샤딩
* 데이터를 수동으로 분산 저장
* 분할된 데이터는 서로 연관관계가 없음

# DB 파티셔닝/샤딩
## 데이터를 특정 속성 중심으로 물리적 분할
* 분할된 데이터는 서로 조인을 하거나 참조가 발생해서는 안됨
* 보통 userId, blogId, boardId 등을 사용

## 데이터를 특정 속성 중심으로 물리적 분할
* 사용자(군) 별로 데이터를 관리
* 파티셔닝
* 테이블 분리를 디비 분리까지
* 어떤 디비를 봐야할 지 판단해야함
    * 매핑 디비 서버 - 데이터 이동이 유연하지만, 별도 서버 운영 필요
    * 해쉬 함수 이용 - 별도 서버 없이 찾기 가능, 데이터 분할 시 많은 데이터를 이동해야할 수 있음

# 셀 아키텍처
## 데이터를 특정 속성 중심으로 물리적 분할
* 웹과 디비 서버 중심으로 분할
* 웹, 디비 서버 이중화
* 사용자군별 어느 디비에 있는지 정보 보관
    * 구분을 웹 서버가 함

## 셀 디비
* 분할된 데이터가 어디에 속하는지 참조
* 전체 사용자가 공통으로 참조
* 셀 디비, 로케이션 디비, 유저 디스커버리 서비스 등등

### 장점
* 셀 단위 스케일링
* 장애를 특정 셀로 고립 가능
* 프론트+백엔드 점진적 배포
* 일부 웹 서버만 선적용하는 것은 흔하고 쉽다
* 디비가 변경되었을 때, 일부 웹 서버만 적용하는 것은 쉽지 않지만, 셀 아키텍처에서는 가능

### 단점
* `SPOF`: 셀!
    * 가장 심각한 문제
    * 하지만 거의 정적인 데이터

* 많은 장비 필요
* 제공하는 기능에 따라 셀간 데이터를 조합해야할 수도
    * 예) 페이스북의 현 계정 친구 정보를 스트림에 추가
* 보통 캐시에 올려서 처리
    * 용량이 얼마 크지 않기 때문에, 처리 가능
    * 2중화, 3중화 처리

## 워드프레스
* 2^n개의 버켓(샤드)을 마련
    * 가상의 버켓을 미리 많이 만들어 두고, 물리 버켓을 매핑
* 하나의 서버에서 운영하다가, 용량이 차면 2대로 분할
    * 또 차면 또 분할
* 리밸런싱을 하기 쉬움
    * DB가 제공해 주는 툴로 가능

## 메일
* 웹 인터페이스
    * HTTP 리다이렉트를 이용하여 속한 셀로 전환 가능

* IMAP, POP3
    * 프로토콜상 어느 셀에서나 모든 사용자 서비스 가능해야 함

## 몇 개의 셀이 적당
* 최소 2개 - 50:50? 10:90??
    * 50:50 등분하면 점진적 배포를 적극 활용하기 어려움
    * 위험이 있는 배포를 조금 선 배포하지 못하고 절반에 적용하게 됨
    * 10:90과 같이 특정 셀을 작게 가져가면 점진적 배포에 유리

## IDC 분할
* 그렇게까지?
* 4개라면 IDC별 2개씩? 혹은 1개, 3개?
* `정책` 문제!!

# 디비 샤딩

1. 기존과 동일하게 서비스에 접속
2. 해당 데이터가 어느 디비에 속해 있는지 질의(Location)
3. 속한 디비에 질의

# 셀 아키텍처
1. 비로그인 상태에서 접속
2. 로그인 후 접속을 받음(introService)
3.어떤 셀에 속한지 물어봄
4.  어디로 redirect할지 돌려줌
5. 해당 셀로 접속 

---
참고: NHN 기술교육 - DB 샤딩